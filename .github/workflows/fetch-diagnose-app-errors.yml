name: Fetch and Diagnose App Errors

on:
  workflow_dispatch:
    inputs:
      time_range:
        description: 'Time range for logs (in minutes, e.g., 60 for last hour)'
        required: false
        default: '60'
      app_name:
        description: 'Azure Web App name'
        required: false
        default: 'mosaic-saas'
      resource_group:
        description: 'Azure Resource Group name'
        required: false
        default: 'orkinosai_group'

env:
  AZURE_WEBAPP_NAME: mosaic-saas
  AZURE_RESOURCE_GROUP: orkinosai_group

jobs:
  fetch-and-diagnose:
    name: Fetch Azure Logs and Diagnose Errors
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Azure Login
      id: azure-login
      uses: azure/login@v2
      continue-on-error: true
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get Azure Web App Details
      id: app-details
      if: steps.azure-login.outcome == 'success'
      run: |
        echo "Fetching Azure Web App details..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        
        echo "Using Resource Group: $RESOURCE_GROUP"
        echo "Using App Name: $APP_NAME"
        
        # Verify resource group exists
        if ! az group show --name "$RESOURCE_GROUP" &>/dev/null; then
          echo "::error::Resource group '$RESOURCE_GROUP' does not exist"
          echo "resource_group_exists=false" >> $GITHUB_OUTPUT
          echo "app_url=N/A" >> $GITHUB_OUTPUT
          echo "app_state=ResourceGroupNotFound" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "resource_group_exists=true" >> $GITHUB_OUTPUT
        
        # Get app URL
        APP_URL=$(az webapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "defaultHostName" -o tsv 2>/dev/null || echo "")
        if [ -n "$APP_URL" ]; then
          echo "app_url=https://$APP_URL" >> $GITHUB_OUTPUT
          echo "‚úì App URL: https://$APP_URL"
        else
          echo "‚ö†Ô∏è Could not retrieve app URL"
          echo "app_url=N/A" >> $GITHUB_OUTPUT
        fi
        
        # Get app state
        APP_STATE=$(az webapp show --name "$APP_NAME" --resource-group "$RESOURCE_GROUP" --query "state" -o tsv 2>/dev/null || echo "Unknown")
        echo "app_state=$APP_STATE" >> $GITHUB_OUTPUT
        echo "‚úì App State: $APP_STATE"
    
    - name: Check App Health
      id: health-check
      if: steps.azure-login.outcome == 'success'
      continue-on-error: true
      run: |
        # Check if resource group exists first
        if [ "${{ steps.app-details.outputs.resource_group_exists }}" = "false" ]; then
          echo "‚ùå Cannot check health - resource group not found"
          echo "health_status=resource_group_not_found" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        APP_URL="${{ steps.app-details.outputs.app_url }}"
        if [ "$APP_URL" = "N/A" ]; then
          echo "‚ùå Cannot check health - app URL not available"
          echo "health_status=error" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Checking health endpoint: $APP_URL/api/health"
        HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL/api/health" || echo "000")
        echo "HTTP Status Code: $HTTP_CODE"
        
        if [ "$HTTP_CODE" = "200" ]; then
          echo "‚úì Health check passed"
          echo "health_status=healthy" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Health check failed with status: $HTTP_CODE"
          echo "health_status=unhealthy" >> $GITHUB_OUTPUT
        fi
    
    - name: Fetch Application Logs
      id: fetch-logs
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      run: |
        echo "Fetching application logs..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        TIME_RANGE="${{ github.event.inputs.time_range || '60' }}"
        
        # Create logs directory
        mkdir -p logs
        
        # Fetch application logs
        echo "Fetching logs from the last $TIME_RANGE minutes..."
        az webapp log download \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --log-file logs/app-logs.zip 2>&1 || echo "‚ö†Ô∏è Could not download full log archive"
        
        # Extract logs if downloaded
        if [ -f logs/app-logs.zip ]; then
          echo "‚úì Logs downloaded successfully"
          cd logs
          unzip -q app-logs.zip 2>/dev/null || echo "‚ö†Ô∏è Could not extract logs"
          cd ..
        fi
        
        # Fetch recent log stream (last 500 lines for better error capture)
        echo "Fetching recent log stream..."
        az webapp log tail \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --only-show-errors 2>/dev/null | head -500 > logs/recent-log-stream.txt || echo "‚ö†Ô∏è Could not fetch log stream"
        
        echo "log_collection_complete=true" >> $GITHUB_OUTPUT
    
    - name: Fetch Docker/Container Logs
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      continue-on-error: true
      run: |
        echo "Fetching container logs..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        
        # Get container logs (if app runs in container)
        # Note: --only-show-errors suppresses Azure CLI warnings, not application log content
        az webapp log show \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --only-show-errors 2>/dev/null > logs/container-logs.txt || echo "‚ö†Ô∏è Container logs not available"
    
    - name: Extract Stdout Startup Errors
      id: extract-errors
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      continue-on-error: true
      run: |
        echo "Extracting startup errors from stdout logs..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        
        # Try to find the most recent stdout log files
        # Azure stores stdout logs in LogFiles/stdout/ directory
        # First, try to access via kudu/scm
        echo "Attempting to fetch stdout logs via kudu..."
        
        # Get the kudu credentials
        KUDU_CREDS=$(az webapp deployment list-publishing-credentials \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --query "{username:publishingUserName, password:publishingPassword}" \
          -o json 2>/dev/null || echo "")
        
        if [ -n "$KUDU_CREDS" ] && [ "$KUDU_CREDS" != "" ]; then
          KUDU_USER=$(echo "$KUDU_CREDS" | jq -r '.username // empty' 2>/dev/null || echo "")
          KUDU_PASS=$(echo "$KUDU_CREDS" | jq -r '.password // empty' 2>/dev/null || echo "")
          
          if [ -n "$KUDU_USER" ] && [ -n "$KUDU_PASS" ]; then
            echo "‚úì Retrieved kudu credentials"
            
            # Try to list stdout log files via kudu API
            KUDU_URL="https://${APP_NAME}.scm.azurewebsites.net"
            echo "Accessing kudu at: $KUDU_URL"
            
            # List files in LogFiles/stdout directory
            STDOUT_FILES=$(curl -s -u "$KUDU_USER:$KUDU_PASS" \
              "$KUDU_URL/api/vfs/LogFiles/stdout/" 2>/dev/null || echo "")
            
            if [ -n "$STDOUT_FILES" ]; then
              echo "‚úì Found stdout log directory"
              
              # Parse the JSON response to get the most recent log file
              # The files are typically named like: stdout_20231222_123456_12345.log
              LATEST_LOG=$(echo "$STDOUT_FILES" | jq -r 'sort_by(.mtime) | reverse | .[0].name // empty' 2>/dev/null || echo "")
              
              if [ -n "$LATEST_LOG" ]; then
                echo "‚úì Latest stdout log file: $LATEST_LOG"
                
                # Download the latest stdout log
                curl -s -u "$KUDU_USER:$KUDU_PASS" \
                  "$KUDU_URL/api/vfs/LogFiles/stdout/$LATEST_LOG" \
                  > logs/latest-stdout.log 2>/dev/null || echo "‚ö†Ô∏è Could not download stdout log"
                
                if [ -f logs/latest-stdout.log ] && [ -s logs/latest-stdout.log ]; then
                  echo "‚úì Downloaded latest stdout log ($(wc -l < logs/latest-stdout.log) lines)"
                  
                  # Extract critical error information
                  echo "" > logs/startup-errors-extracted.txt
                  echo "=====================================" >> logs/startup-errors-extracted.txt
                  echo "STARTUP ERROR EXTRACTION" >> logs/startup-errors-extracted.txt
                  echo "=====================================" >> logs/startup-errors-extracted.txt
                  echo "Source: $LATEST_LOG" >> logs/startup-errors-extracted.txt
                  echo "Time: $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> logs/startup-errors-extracted.txt
                  echo "" >> logs/startup-errors-extracted.txt
                  
                  # Look for critical error patterns
                  ERROR_FOUND=false
                  
                  # Check for HTTP 500.30 errors
                  if grep -i "500.30\|failed to start" logs/latest-stdout.log > /tmp/error_500_30.txt 2>/dev/null; then
                    echo "‚ùå HTTP 500.30 ERROR DETECTED" >> logs/startup-errors-extracted.txt
                    echo "" >> logs/startup-errors-extracted.txt
                    cat /tmp/error_500_30.txt >> logs/startup-errors-extracted.txt
                    echo "" >> logs/startup-errors-extracted.txt
                    ERROR_FOUND=true
                  fi
                  
                  # Check for exceptions
                  if grep -i "exception\|error\|fail" logs/latest-stdout.log | tail -20 > /tmp/error_exceptions.txt 2>/dev/null; then
                    if [ -s /tmp/error_exceptions.txt ]; then
                      echo "=====================================" >> logs/startup-errors-extracted.txt
                      echo "RECENT ERRORS/EXCEPTIONS (Last 20 lines):" >> logs/startup-errors-extracted.txt
                      echo "" >> logs/startup-errors-extracted.txt
                      cat /tmp/error_exceptions.txt >> logs/startup-errors-extracted.txt
                      echo "" >> logs/startup-errors-extracted.txt
                      ERROR_FOUND=true
                    fi
                  fi
                  
                  # Get the last 50 lines of the log for context
                  echo "=====================================" >> logs/startup-errors-extracted.txt
                  echo "LAST 50 LINES OF STDOUT LOG:" >> logs/startup-errors-extracted.txt
                  echo "" >> logs/startup-errors-extracted.txt
                  tail -50 logs/latest-stdout.log >> logs/startup-errors-extracted.txt
                  
                  if [ "$ERROR_FOUND" = "true" ]; then
                    echo "has_startup_errors=true" >> $GITHUB_OUTPUT
                  else
                    echo "has_startup_errors=false" >> $GITHUB_OUTPUT
                  fi
                  
                  echo "‚úì Error extraction completed"
                else
                  echo "‚ö†Ô∏è Stdout log file is empty or could not be downloaded"
                  echo "has_startup_errors=unknown" >> $GITHUB_OUTPUT
                fi
              else
                echo "‚ö†Ô∏è No stdout log files found in directory"
                echo "has_startup_errors=unknown" >> $GITHUB_OUTPUT
              fi
            else
              echo "‚ö†Ô∏è Could not access stdout log directory"
              echo "has_startup_errors=unknown" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è Could not parse kudu credentials"
            echo "has_startup_errors=unknown" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ö†Ô∏è Could not retrieve kudu credentials"
          echo "has_startup_errors=unknown" >> $GITHUB_OUTPUT
        fi
    
    - name: Fetch Event Logs
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      continue-on-error: true
      run: |
        echo "Fetching Azure activity logs..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        TIME_RANGE="${{ github.event.inputs.time_range || '60' }}"
        
        # Calculate start time
        START_TIME=$(date -u -d "$TIME_RANGE minutes ago" +"%Y-%m-%dT%H:%M:%SZ")
        
        # Fetch activity logs
        az monitor activity-log list \
          --resource-group "$RESOURCE_GROUP" \
          --start-time "$START_TIME" \
          --query "[?contains(resourceId, '$APP_NAME')]" \
          --output json > logs/activity-logs.json 2>/dev/null || echo "‚ö†Ô∏è Activity logs not available"
    
    - name: Get App Service Configuration
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      continue-on-error: true
      run: |
        echo "Fetching app configuration..."
        APP_NAME="${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
        RESOURCE_GROUP="${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
        
        # Get app settings (secrets will be masked)
        az webapp config appsettings list \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --output json > logs/app-settings.json 2>/dev/null || echo "‚ö†Ô∏è App settings not available"
        
        # Get connection strings (values will be masked for security)
        az webapp config connection-string list \
          --name "$APP_NAME" \
          --resource-group "$RESOURCE_GROUP" \
          --output json > logs/connection-strings.json 2>/dev/null || echo "‚ö†Ô∏è Connection strings not available"
    
    - name: Analyze Logs for Common Errors
      id: analyze-errors
      if: steps.azure-login.outcome == 'success'
      run: |
        echo "Analyzing logs for common errors..."
        
        # Create analysis report header
        {
          echo "========================================"
          echo "MOSAIC Azure App Error Analysis Report"
          echo "========================================"
          echo "Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo "Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo ""
          echo "App Details:"
          echo "- Name: ${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
          echo "- URL: ${{ steps.app-details.outputs.app_url }}"
          echo "- State: ${{ steps.app-details.outputs.app_state }}"
          echo "- Health Status: ${{ steps.health-check.outputs.health_status }}"
          echo ""
          echo "========================================"
          echo "Common Error Patterns Detected"
          echo "========================================"
          echo ""
        } > logs/error-analysis.txt
        
        # Search for common error patterns in all log files
        ERROR_FOUND=false
        
        # Check for HTTP 500.30 errors
        if grep -r "500.30" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå HTTP 500.30 ERROR DETECTED" >> logs/error-analysis.txt
          echo "   - ASP.NET Core app failed to start" >> logs/error-analysis.txt
          echo "   - See TROUBLESHOOTING_HTTP_500_30.md for detailed guidance" >> logs/error-analysis.txt
          echo "   - Common causes: missing connection string, database issues, config errors" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        # Check for database connection errors
        if grep -ri "connection.*fail\|cannot connect\|timeout.*database\|SqlException" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå DATABASE CONNECTION ERROR DETECTED" >> logs/error-analysis.txt
          echo "   - Check connection string in Azure Portal ‚Üí Configuration" >> logs/error-analysis.txt
          echo "   - Verify database server is accessible" >> logs/error-analysis.txt
          echo "   - Ensure firewall rules allow Azure services" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        # Check for authentication errors
        if grep -ri "authentication.*fail\|unauthorized\|401\|403" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå AUTHENTICATION ERROR DETECTED" >> logs/error-analysis.txt
          echo "   - Check JWT configuration" >> logs/error-analysis.txt
          echo "   - Verify Identity configuration" >> logs/error-analysis.txt
          echo "   - Review AUTHENTICATION_README.md" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        # Check for missing dependencies/files
        if grep -ri "FileNotFoundException\|could not find file\|missing.*dll" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå MISSING FILES/DEPENDENCIES DETECTED" >> logs/error-analysis.txt
          echo "   - Verify deployment package is complete" >> logs/error-analysis.txt
          echo "   - Check web.config exists in deployment" >> logs/error-analysis.txt
          echo "   - Ensure all NuGet packages are included" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        # Check for memory/resource issues
        if grep -ri "OutOfMemoryException\|memory.*limit\|quota.*exceed" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå MEMORY/RESOURCE ERROR DETECTED" >> logs/error-analysis.txt
          echo "   - Consider scaling up App Service plan" >> logs/error-analysis.txt
          echo "   - Review memory usage patterns" >> logs/error-analysis.txt
          echo "   - Check for memory leaks" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        # Check for configuration errors
        if grep -ri "configuration.*error\|InvalidOperationException.*config\|missing.*setting" logs/ 2>/dev/null > /tmp/error_check.txt; then
          echo "" >> logs/error-analysis.txt
          echo "‚ùå CONFIGURATION ERROR DETECTED" >> logs/error-analysis.txt
          echo "   - Verify all required app settings in Azure Portal" >> logs/error-analysis.txt
          echo "   - Check .env.example for required variables" >> logs/error-analysis.txt
          echo "   - Review DEPLOYMENT_NOTES.md" >> logs/error-analysis.txt
          head -5 /tmp/error_check.txt >> logs/error-analysis.txt
          ERROR_FOUND=true
        fi
        
        if [ "$ERROR_FOUND" = "false" ]; then
          echo "" >> logs/error-analysis.txt
          echo "‚úì No common error patterns detected in logs" >> logs/error-analysis.txt
          echo "  Review the full logs for detailed information" >> logs/error-analysis.txt
        fi
        
        echo "" >> logs/error-analysis.txt
        echo "========================================" >> logs/error-analysis.txt
        echo "Next Steps" >> logs/error-analysis.txt
        echo "========================================" >> logs/error-analysis.txt
        echo "1. Download the workflow artifacts (logs)" >> logs/error-analysis.txt
        echo "2. Review error-analysis.txt for detected issues" >> logs/error-analysis.txt
        echo "3. Check recent-log-stream.txt for recent errors" >> logs/error-analysis.txt
        echo "4. Consult relevant troubleshooting docs in repository" >> logs/error-analysis.txt
        echo "5. If needed, enable more detailed logging in Azure Portal" >> logs/error-analysis.txt
        echo "" >> logs/error-analysis.txt
        echo "Relevant Documentation:" >> logs/error-analysis.txt
        echo "- TROUBLESHOOTING_HTTP_500_30.md" >> logs/error-analysis.txt
        echo "- DEPLOYMENT_NOTES.md" >> logs/error-analysis.txt
        echo "- AUTHENTICATION_README.md" >> logs/error-analysis.txt
        echo "- ERROR_LOGGING_TROUBLESHOOTING.md" >> logs/error-analysis.txt
        
        # Display the analysis
        cat logs/error-analysis.txt
        
        # Set output for summary
        if [ "$ERROR_FOUND" = "true" ]; then
          echo "errors_detected=true" >> $GITHUB_OUTPUT
        else
          echo "errors_detected=false" >> $GITHUB_OUTPUT
        fi
    
    - name: Create Diagnostic Summary
      if: steps.azure-login.outcome == 'success' && steps.app-details.outputs.resource_group_exists == 'true'
      run: |
        {
          echo "# Azure App Diagnostic Summary"
          echo ""
          echo "## Workflow Information"
          echo "- **Run ID**: ${{ github.run_id }}"
          echo "- **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          echo "- **Triggered By**: ${{ github.actor }}"
          echo "- **Timestamp**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
          echo ""
          echo "## Application Information"
          echo "- **App Name**: ${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}"
          echo "- **Resource Group**: ${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}"
          echo "- **App URL**: ${{ steps.app-details.outputs.app_url }}"
          echo "- **App State**: ${{ steps.app-details.outputs.app_state }}"
          echo "- **Health Status**: ${{ steps.health-check.outputs.health_status }}"
          echo ""
          echo "## Log Collection Summary"
          echo "- **Time Range**: Last ${{ github.event.inputs.time_range || '60' }} minutes"
          echo "- **Logs Collected**: ${{ steps.fetch-logs.outputs.log_collection_complete }}"
          echo "- **Errors Detected**: ${{ steps.analyze-errors.outputs.errors_detected }}"
          echo "- **Startup Errors Extracted**: ${{ steps.extract-errors.outputs.has_startup_errors }}"
          echo ""
          echo "## Files in This Artifact"
          echo "1. **startup-errors-extracted.txt** - üî• **START HERE** - Extracted startup errors from stdout logs"
          echo "2. **latest-stdout.log** - Complete stdout log from Azure App Service"
          echo "3. **error-analysis.txt** - Automated error pattern analysis"
          echo "4. **recent-log-stream.txt** - Recent application logs (last 500 lines)"
          echo "5. **DIAGNOSTIC_SUMMARY.md** - This file"
          echo "6. **app-logs.zip** - Full log archive (if available)"
          echo "7. **container-logs.txt** - Container/Docker logs (if available)"
          echo "8. **activity-logs.json** - Azure activity logs (if available)"
          echo "9. **app-settings.json** - Application settings (secrets masked)"
          echo "10. **connection-strings.json** - Connection string names (values masked)"
          echo ""
          echo "## Quick Actions"
          echo ""
          echo "### If Health Check Failed"
          echo "1. **PRIORITY**: Check **startup-errors-extracted.txt** for the actual startup error"
          echo "2. Review **latest-stdout.log** for full error context"
          echo "3. Check **error-analysis.txt** for detected issues"
          echo "4. Review **recent-log-stream.txt** for error details"
          echo "5. Verify database connection in Azure Portal"
          echo "6. Check all environment variables are set correctly"
          echo ""
          echo "### If No Errors Detected"
          echo "1. Review logs manually for warnings or performance issues"
          echo "2. Check application metrics in Azure Portal"
          echo "3. Consider enabling more verbose logging"
          echo ""
          echo "## Recommended Next Steps"
          echo "1. Review the error analysis report"
          echo "2. Consult relevant troubleshooting documentation:"
          echo "   - \`TROUBLESHOOTING_HTTP_500_30.md\`"
          echo "   - \`DEPLOYMENT_NOTES.md\`"
          echo "   - \`ERROR_LOGGING_TROUBLESHOOTING.md\`"
          echo "3. Apply fixes based on identified issues"
          echo "4. Re-run this workflow after fixes to verify resolution"
          echo ""
          echo "## Additional Resources"
          echo "- [Azure Portal - App Service Logs](https://portal.azure.com/#blade/Microsoft_Azure_Monitoring_Logs/LogsBlade)"
          echo "- [Kudu Console](https://${{ env.AZURE_WEBAPP_NAME }}.scm.azurewebsites.net)"
          echo "- [Azure Monitor](https://portal.azure.com/#blade/Microsoft_Azure_Monitoring/AzureMonitoringBrowseBlade)"
          echo ""
          echo "---"
          echo "*This diagnostic report was automatically generated by GitHub Actions*"
        } > logs/DIAGNOSTIC_SUMMARY.md
        
        # Display summary
        cat logs/DIAGNOSTIC_SUMMARY.md
    
    - name: Upload Logs as Artifact
      uses: actions/upload-artifact@v4
      if: always() && steps.azure-login.outcome == 'success'
      with:
        name: azure-app-logs-${{ github.run_number }}
        path: logs/
        retention-days: 30
    
    - name: Create Workflow Summary
      if: always()
      run: |
        echo "## üîç Azure App Diagnostics Complete" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # Check if Azure login failed
        if [ "${{ steps.azure-login.outcome }}" != "success" ]; then
          echo "### ‚ùå Azure Login Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The workflow could not authenticate with Azure. This is usually caused by:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Invalid or expired Azure credentials** in the \`AZURE_CREDENTIALS\` secret" >> $GITHUB_STEP_SUMMARY
          echo "2. **Incorrect client secret** - ensure you're using the secret value, not the secret ID" >> $GITHUB_STEP_SUMMARY
          echo "3. **Expired service principal** credentials" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üìñ Complete Fix Guide:** [AZURE_CREDENTIALS_FIX_GUIDE.md](https://github.com/${{ github.repository }}/blob/main/AZURE_CREDENTIALS_FIX_GUIDE.md)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Quick Fix Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to Azure Portal ‚Üí Azure Active Directory ‚Üí App registrations" >> $GITHUB_STEP_SUMMARY
          echo "2. Find your service principal and create a new client secret" >> $GITHUB_STEP_SUMMARY
          echo "3. Update the \`AZURE_CREDENTIALS\` secret in GitHub with the new credentials" >> $GITHUB_STEP_SUMMARY
          echo "4. Ensure the secret JSON includes: \`clientId\`, \`clientSecret\`, \`subscriptionId\`, and \`tenantId\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Additional Resources:**" >> $GITHUB_STEP_SUMMARY
          echo "- [Azure Login Action](https://github.com/Azure/login#configure-a-service-principal-with-a-secret)" >> $GITHUB_STEP_SUMMARY
          echo "- [Azure Service Principal Setup](https://learn.microsoft.com/en-us/azure/active-directory/develop/howto-create-service-principal-portal)" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ steps.app-details.outputs.resource_group_exists }}" = "false" ]; then
          echo "### ‚ùå Azure Resource Group Not Found" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Resource Group:** \`${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The specified Azure resource group does not exist. This could mean:" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "1. **Incorrect resource group name** - The resource group name in the workflow doesn't match your Azure setup" >> $GITHUB_STEP_SUMMARY
          echo "2. **Resource group was deleted** - Check Azure Portal to verify" >> $GITHUB_STEP_SUMMARY
          echo "3. **Wrong Azure subscription** - Verify the service principal has access to the correct subscription" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**How to Fix:**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Option 1:** Re-run the workflow with the correct resource group name:" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to the [Actions tab](${{ github.server_url }}/${{ github.repository }}/actions/workflows/fetch-diagnose-app-errors.yml)" >> $GITHUB_STEP_SUMMARY
          echo "2. Click **Run workflow**" >> $GITHUB_STEP_SUMMARY
          echo "3. Enter the correct **resource_group** name" >> $GITHUB_STEP_SUMMARY
          echo "4. Click **Run workflow** to start" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Option 2:** Update the workflow file to use the correct default:" >> $GITHUB_STEP_SUMMARY
          echo "1. Edit \`.github/workflows/fetch-diagnose-app-errors.yml\`" >> $GITHUB_STEP_SUMMARY
          echo "2. Change the \`AZURE_RESOURCE_GROUP\` value (line 18)" >> $GITHUB_STEP_SUMMARY
          echo "3. Commit and re-run the workflow" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**To find your resource group name:**" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "az group list --query '[].{Name:name, Location:location}' -o table" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        else
          echo "### Application Status" >> $GITHUB_STEP_SUMMARY
          echo "- **App**: ${{ github.event.inputs.app_name || env.AZURE_WEBAPP_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Resource Group**: ${{ github.event.inputs.resource_group || env.AZURE_RESOURCE_GROUP }}" >> $GITHUB_STEP_SUMMARY
          echo "- **URL**: ${{ steps.app-details.outputs.app_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- **State**: ${{ steps.app-details.outputs.app_state }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Health**: ${{ steps.health-check.outputs.health_status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # Display extracted startup errors if available
          if [ "${{ steps.extract-errors.outputs.has_startup_errors }}" = "true" ]; then
            echo "### üî• Startup Errors Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Critical startup errors were extracted from stdout logs:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # Display the extracted errors in the summary
            if [ -f logs/startup-errors-extracted.txt ]; then
              echo '```' >> $GITHUB_STEP_SUMMARY
              # Show first 50 lines of extracted errors
              head -50 logs/startup-errors-extracted.txt >> $GITHUB_STEP_SUMMARY
              echo '```' >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "üì• **Download the full error log**: Check the \`startup-errors-extracted.txt\` file in the artifacts below." >> $GITHUB_STEP_SUMMARY
            else
              echo "‚ö†Ô∏è Error extraction completed but file not found. Check artifacts for details." >> $GITHUB_STEP_SUMMARY
            fi
            echo "" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.extract-errors.outputs.has_startup_errors }}" = "false" ]; then
            echo "### ‚úÖ No Startup Errors in Stdout Logs" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The stdout logs were checked but no obvious startup errors were found." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [ "${{ steps.analyze-errors.outputs.errors_detected }}" = "true" ]; then
            echo "### ‚ö†Ô∏è Additional Errors Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Common error patterns were found in the logs. Please review the artifact for details." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ steps.extract-errors.outputs.has_startup_errors }}" != "true" ]; then
            echo "### ‚úÖ No Common Errors Detected" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "No common error patterns found. Review logs manually for detailed analysis." >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìö Documentation" >> $GITHUB_STEP_SUMMARY
          echo "- [Troubleshooting HTTP 500.30](https://github.com/${{ github.repository }}/blob/main/TROUBLESHOOTING_HTTP_500_30.md)" >> $GITHUB_STEP_SUMMARY
          echo "- [Deployment Notes](https://github.com/${{ github.repository }}/blob/main/DEPLOYMENT_NOTES.md)" >> $GITHUB_STEP_SUMMARY
          echo "- [Error Logging Guide](https://github.com/${{ github.repository }}/blob/main/ERROR_LOGGING_TROUBLESHOOTING.md)" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üì¶ Artifacts" >> $GITHUB_STEP_SUMMARY
          echo "All logs have been collected and uploaded as workflow artifacts." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üî• IMPORTANT**: Download artifacts and check \`startup-errors-extracted.txt\` first for the actual startup error!" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Download artifacts**: [azure-app-logs-${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
        fi
    
    - name: Fail Workflow if Azure Login Failed
      if: always() && steps.azure-login.outcome != 'success'
      run: |
        echo "::error::Azure login failed. Cannot proceed with diagnostics."
        exit 1
    
    - name: Azure Logout
      if: always() && steps.azure-login.outcome == 'success'
      run: |
        az logout
